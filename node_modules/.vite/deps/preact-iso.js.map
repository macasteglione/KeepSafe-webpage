{
  "version": 3,
  "sources": ["../../preact/hooks/src/index.js", "../../preact-iso/src/router.js", "../../preact-iso/src/lazy.js", "../../preact-iso/src/hydrate.js", "../../preact-iso/src/index.js"],
  "sourcesContent": ["import { options as _options } from 'preact';\n\n/** @type {number} */\nlet currentIndex;\n\n/** @type {import('./internal').Component} */\nlet currentComponent;\n\n/** @type {import('./internal').Component} */\nlet previousComponent;\n\n/** @type {number} */\nlet currentHook = 0;\n\n/** @type {Array<import('./internal').Component>} */\nlet afterPaintEffects = [];\n\n// Cast to use internal Options type\nconst options = /** @type {import('./internal').Options} */ (_options);\n\nlet oldBeforeDiff = options._diff;\nlet oldBeforeRender = options._render;\nlet oldAfterDiff = options.diffed;\nlet oldCommit = options._commit;\nlet oldBeforeUnmount = options.unmount;\nlet oldRoot = options._root;\n\n// We take the minimum timeout for requestAnimationFrame to ensure that\n// the callback is invoked after the next frame. 35ms is based on a 30hz\n// refresh rate, which is the minimum rate for a smooth user experience.\nconst RAF_TIMEOUT = 35;\nlet prevRaf;\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._diff = vnode => {\n\tcurrentComponent = null;\n\tif (oldBeforeDiff) oldBeforeDiff(vnode);\n};\n\noptions._root = (vnode, parentDom) => {\n\tif (vnode && parentDom._children && parentDom._children._mask) {\n\t\tvnode._mask = parentDom._children._mask;\n\t}\n\n\tif (oldRoot) oldRoot(vnode, parentDom);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions._render = vnode => {\n\tif (oldBeforeRender) oldBeforeRender(vnode);\n\n\tcurrentComponent = vnode._component;\n\tcurrentIndex = 0;\n\n\tconst hooks = currentComponent.__hooks;\n\tif (hooks) {\n\t\tif (previousComponent === currentComponent) {\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentComponent._renderCallbacks = [];\n\t\t\thooks._list.forEach(hookItem => {\n\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t}\n\t\t\t\thookItem._pendingArgs = hookItem._nextValue = undefined;\n\t\t\t});\n\t\t} else {\n\t\t\thooks._pendingEffects.forEach(invokeCleanup);\n\t\t\thooks._pendingEffects.forEach(invokeEffect);\n\t\t\thooks._pendingEffects = [];\n\t\t\tcurrentIndex = 0;\n\t\t}\n\t}\n\tpreviousComponent = currentComponent;\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.diffed = vnode => {\n\tif (oldAfterDiff) oldAfterDiff(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tif (c.__hooks._pendingEffects.length) afterPaint(afterPaintEffects.push(c));\n\t\tc.__hooks._list.forEach(hookItem => {\n\t\t\tif (hookItem._pendingArgs) {\n\t\t\t\thookItem._args = hookItem._pendingArgs;\n\t\t\t}\n\t\t\thookItem._pendingArgs = undefined;\n\t\t});\n\t}\n\tpreviousComponent = currentComponent = null;\n};\n\n// TODO: Improve typing of commitQueue parameter\n/** @type {(vnode: import('./internal').VNode, commitQueue: any) => void} */\noptions._commit = (vnode, commitQueue) => {\n\tcommitQueue.some(component => {\n\t\ttry {\n\t\t\tcomponent._renderCallbacks.forEach(invokeCleanup);\n\t\t\tcomponent._renderCallbacks = component._renderCallbacks.filter(cb =>\n\t\t\t\tcb._value ? invokeEffect(cb) : true\n\t\t\t);\n\t\t} catch (e) {\n\t\t\tcommitQueue.some(c => {\n\t\t\t\tif (c._renderCallbacks) c._renderCallbacks = [];\n\t\t\t});\n\t\t\tcommitQueue = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t});\n\n\tif (oldCommit) oldCommit(vnode, commitQueue);\n};\n\n/** @type {(vnode: import('./internal').VNode) => void} */\noptions.unmount = vnode => {\n\tif (oldBeforeUnmount) oldBeforeUnmount(vnode);\n\n\tconst c = vnode._component;\n\tif (c && c.__hooks) {\n\t\tlet hasErrored;\n\t\tc.__hooks._list.forEach(s => {\n\t\t\ttry {\n\t\t\t\tinvokeCleanup(s);\n\t\t\t} catch (e) {\n\t\t\t\thasErrored = e;\n\t\t\t}\n\t\t});\n\t\tc.__hooks = undefined;\n\t\tif (hasErrored) options._catchError(hasErrored, c._vnode);\n\t}\n};\n\n/**\n * Get a hook's state from the currentComponent\n * @param {number} index The index of the hook to get\n * @param {number} type The index of the hook to get\n * @returns {any}\n */\nfunction getHookState(index, type) {\n\tif (options._hook) {\n\t\toptions._hook(currentComponent, index, currentHook || type);\n\t}\n\tcurrentHook = 0;\n\n\t// Largely inspired by:\n\t// * https://github.com/michael-klein/funcy.js/blob/f6be73468e6ec46b0ff5aa3cc4c9baf72a29025a/src/hooks/core_hooks.mjs\n\t// * https://github.com/michael-klein/funcy.js/blob/650beaa58c43c33a74820a3c98b3c7079cf2e333/src/renderer.mjs\n\t// Other implementations to look at:\n\t// * https://codesandbox.io/s/mnox05qp8\n\tconst hooks =\n\t\tcurrentComponent.__hooks ||\n\t\t(currentComponent.__hooks = {\n\t\t\t_list: [],\n\t\t\t_pendingEffects: []\n\t\t});\n\n\tif (index >= hooks._list.length) {\n\t\thooks._list.push({});\n\t}\n\n\treturn hooks._list[index];\n}\n\n/**\n * @template {unknown} S\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} [initialState]\n * @returns {[S, (state: S) => void]}\n */\nexport function useState(initialState) {\n\tcurrentHook = 1;\n\treturn useReducer(invokeOrReturn, initialState);\n}\n\n/**\n * @template {unknown} S\n * @template {unknown} A\n * @param {import('./index').Reducer<S, A>} reducer\n * @param {import('./index').Dispatch<import('./index').StateUpdater<S>>} initialState\n * @param {(initialState: any) => void} [init]\n * @returns {[ S, (state: S) => void ]}\n */\nexport function useReducer(reducer, initialState, init) {\n\t/** @type {import('./internal').ReducerHookState} */\n\tconst hookState = getHookState(currentIndex++, 2);\n\thookState._reducer = reducer;\n\tif (!hookState._component) {\n\t\thookState._value = [\n\t\t\t!init ? invokeOrReturn(undefined, initialState) : init(initialState),\n\n\t\t\taction => {\n\t\t\t\tconst currentValue = hookState._nextValue\n\t\t\t\t\t? hookState._nextValue[0]\n\t\t\t\t\t: hookState._value[0];\n\t\t\t\tconst nextValue = hookState._reducer(currentValue, action);\n\n\t\t\t\tif (currentValue !== nextValue) {\n\t\t\t\t\thookState._nextValue = [nextValue, hookState._value[1]];\n\t\t\t\t\thookState._component.setState({});\n\t\t\t\t}\n\t\t\t}\n\t\t];\n\n\t\thookState._component = currentComponent;\n\n\t\tif (!currentComponent._hasScuFromHooks) {\n\t\t\tcurrentComponent._hasScuFromHooks = true;\n\t\t\tlet prevScu = currentComponent.shouldComponentUpdate;\n\t\t\tconst prevCWU = currentComponent.componentWillUpdate;\n\n\t\t\t// If we're dealing with a forced update `shouldComponentUpdate` will\n\t\t\t// not be called. But we use that to update the hook values, so we\n\t\t\t// need to call it.\n\t\t\tcurrentComponent.componentWillUpdate = function (p, s, c) {\n\t\t\t\tif (this._force) {\n\t\t\t\t\tlet tmp = prevScu;\n\t\t\t\t\t// Clear to avoid other sCU hooks from being called\n\t\t\t\t\tprevScu = undefined;\n\t\t\t\t\tupdateHookState(p, s, c);\n\t\t\t\t\tprevScu = tmp;\n\t\t\t\t}\n\n\t\t\t\tif (prevCWU) prevCWU.call(this, p, s, c);\n\t\t\t};\n\n\t\t\t// This SCU has the purpose of bailing out after repeated updates\n\t\t\t// to stateful hooks.\n\t\t\t// we store the next value in _nextValue[0] and keep doing that for all\n\t\t\t// state setters, if we have next states and\n\t\t\t// all next states within a component end up being equal to their original state\n\t\t\t// we are safe to bail out for this specific component.\n\t\t\t/**\n\t\t\t *\n\t\t\t * @type {import('./internal').Component[\"shouldComponentUpdate\"]}\n\t\t\t */\n\t\t\t// @ts-ignore - We don't use TS to downtranspile\n\t\t\t// eslint-disable-next-line no-inner-declarations\n\t\t\tfunction updateHookState(p, s, c) {\n\t\t\t\tif (!hookState._component.__hooks) return true;\n\n\t\t\t\t/** @type {(x: import('./internal').HookState) => x is import('./internal').ReducerHookState} */\n\t\t\t\tconst isStateHook = x => !!x._component;\n\t\t\t\tconst stateHooks =\n\t\t\t\t\thookState._component.__hooks._list.filter(isStateHook);\n\n\t\t\t\tconst allHooksEmpty = stateHooks.every(x => !x._nextValue);\n\t\t\t\t// When we have no updated hooks in the component we invoke the previous SCU or\n\t\t\t\t// traverse the VDOM tree further.\n\t\t\t\tif (allHooksEmpty) {\n\t\t\t\t\treturn prevScu ? prevScu.call(this, p, s, c) : true;\n\t\t\t\t}\n\n\t\t\t\t// We check whether we have components with a nextValue set that\n\t\t\t\t// have values that aren't equal to one another this pushes\n\t\t\t\t// us to update further down the tree\n\t\t\t\tlet shouldUpdate = hookState._component.props !== p;\n\t\t\t\tstateHooks.forEach(hookItem => {\n\t\t\t\t\tif (hookItem._nextValue) {\n\t\t\t\t\t\tconst currentValue = hookItem._value[0];\n\t\t\t\t\t\thookItem._value = hookItem._nextValue;\n\t\t\t\t\t\thookItem._nextValue = undefined;\n\t\t\t\t\t\tif (currentValue !== hookItem._value[0]) shouldUpdate = true;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn prevScu\n\t\t\t\t\t? prevScu.call(this, p, s, c) || shouldUpdate\n\t\t\t\t\t: shouldUpdate;\n\t\t\t}\n\n\t\t\tcurrentComponent.shouldComponentUpdate = updateHookState;\n\t\t}\n\t}\n\n\treturn hookState._nextValue || hookState._value;\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 3);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent.__hooks._pendingEffects.push(state);\n\t}\n}\n\n/**\n * @param {import('./internal').Effect} callback\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useLayoutEffect(callback, args) {\n\t/** @type {import('./internal').EffectHookState} */\n\tconst state = getHookState(currentIndex++, 4);\n\tif (!options._skipEffects && argsChanged(state._args, args)) {\n\t\tstate._value = callback;\n\t\tstate._pendingArgs = args;\n\n\t\tcurrentComponent._renderCallbacks.push(state);\n\t}\n}\n\n/** @type {(initialValue: unknown) => unknown} */\nexport function useRef(initialValue) {\n\tcurrentHook = 5;\n\treturn useMemo(() => ({ current: initialValue }), []);\n}\n\n/**\n * @param {object} ref\n * @param {() => object} createHandle\n * @param {unknown[]} args\n * @returns {void}\n */\nexport function useImperativeHandle(ref, createHandle, args) {\n\tcurrentHook = 6;\n\tuseLayoutEffect(\n\t\t() => {\n\t\t\tif (typeof ref == 'function') {\n\t\t\t\tconst result = ref(createHandle());\n\t\t\t\treturn () => {\n\t\t\t\t\tref(null);\n\t\t\t\t\tif (result && typeof result == 'function') result();\n\t\t\t\t};\n\t\t\t} else if (ref) {\n\t\t\t\tref.current = createHandle();\n\t\t\t\treturn () => (ref.current = null);\n\t\t\t}\n\t\t},\n\t\targs == null ? args : args.concat(ref)\n\t);\n}\n\n/**\n * @template {unknown} T\n * @param {() => T} factory\n * @param {unknown[]} args\n * @returns {T}\n */\nexport function useMemo(factory, args) {\n\t/** @type {import('./internal').MemoHookState<T>} */\n\tconst state = getHookState(currentIndex++, 7);\n\tif (argsChanged(state._args, args)) {\n\t\tstate._value = factory();\n\t\tstate._args = args;\n\t\tstate._factory = factory;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * @param {() => void} callback\n * @param {unknown[]} args\n * @returns {() => void}\n */\nexport function useCallback(callback, args) {\n\tcurrentHook = 8;\n\treturn useMemo(() => callback, args);\n}\n\n/**\n * @param {import('./internal').PreactContext} context\n */\nexport function useContext(context) {\n\tconst provider = currentComponent.context[context._id];\n\t// We could skip this call here, but than we'd not call\n\t// `options._hook`. We need to do that in order to make\n\t// the devtools aware of this hook.\n\t/** @type {import('./internal').ContextHookState} */\n\tconst state = getHookState(currentIndex++, 9);\n\t// The devtools needs access to the context object to\n\t// be able to pull of the default value when no provider\n\t// is present in the tree.\n\tstate._context = context;\n\tif (!provider) return context._defaultValue;\n\t// This is probably not safe to convert to \"!\"\n\tif (state._value == null) {\n\t\tstate._value = true;\n\t\tprovider.sub(currentComponent);\n\t}\n\treturn provider.props.value;\n}\n\n/**\n * Display a custom label for a custom hook for the devtools panel\n * @type {<T>(value: T, cb?: (value: T) => string | number) => void}\n */\nexport function useDebugValue(value, formatter) {\n\tif (options.useDebugValue) {\n\t\toptions.useDebugValue(\n\t\t\tformatter ? formatter(value) : /** @type {any}*/ (value)\n\t\t);\n\t}\n}\n\n/**\n * @param {(error: unknown, errorInfo: import('preact').ErrorInfo) => void} cb\n * @returns {[unknown, () => void]}\n */\nexport function useErrorBoundary(cb) {\n\t/** @type {import('./internal').ErrorBoundaryHookState} */\n\tconst state = getHookState(currentIndex++, 10);\n\tconst errState = useState();\n\tstate._value = cb;\n\tif (!currentComponent.componentDidCatch) {\n\t\tcurrentComponent.componentDidCatch = (err, errorInfo) => {\n\t\t\tif (state._value) state._value(err, errorInfo);\n\t\t\terrState[1](err);\n\t\t};\n\t}\n\treturn [\n\t\terrState[0],\n\t\t() => {\n\t\t\terrState[1](undefined);\n\t\t}\n\t];\n}\n\n/** @type {() => string} */\nexport function useId() {\n\t/** @type {import('./internal').IdHookState} */\n\tconst state = getHookState(currentIndex++, 11);\n\tif (!state._value) {\n\t\t// Grab either the root node or the nearest async boundary node.\n\t\t/** @type {import('./internal').VNode} */\n\t\tlet root = currentComponent._vnode;\n\t\twhile (root !== null && !root._mask && root._parent !== null) {\n\t\t\troot = root._parent;\n\t\t}\n\n\t\tlet mask = root._mask || (root._mask = [0, 0]);\n\t\tstate._value = 'P' + mask[0] + '-' + mask[1]++;\n\t}\n\n\treturn state._value;\n}\n\n/**\n * After paint effects consumer.\n */\nfunction flushAfterPaintEffects() {\n\tlet component;\n\twhile ((component = afterPaintEffects.shift())) {\n\t\tif (!component._parentDom || !component.__hooks) continue;\n\t\ttry {\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeCleanup);\n\t\t\tcomponent.__hooks._pendingEffects.forEach(invokeEffect);\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t} catch (e) {\n\t\t\tcomponent.__hooks._pendingEffects = [];\n\t\t\toptions._catchError(e, component._vnode);\n\t\t}\n\t}\n}\n\nlet HAS_RAF = typeof requestAnimationFrame == 'function';\n\n/**\n * Schedule a callback to be invoked after the browser has a chance to paint a new frame.\n * Do this by combining requestAnimationFrame (rAF) + setTimeout to invoke a callback after\n * the next browser frame.\n *\n * Also, schedule a timeout in parallel to the the rAF to ensure the callback is invoked\n * even if RAF doesn't fire (for example if the browser tab is not visible)\n *\n * @param {() => void} callback\n */\nfunction afterNextFrame(callback) {\n\tconst done = () => {\n\t\tclearTimeout(timeout);\n\t\tif (HAS_RAF) cancelAnimationFrame(raf);\n\t\tsetTimeout(callback);\n\t};\n\tconst timeout = setTimeout(done, RAF_TIMEOUT);\n\n\tlet raf;\n\tif (HAS_RAF) {\n\t\traf = requestAnimationFrame(done);\n\t}\n}\n\n// Note: if someone used options.debounceRendering = requestAnimationFrame,\n// then effects will ALWAYS run on the NEXT frame instead of the current one, incurring a ~16ms delay.\n// Perhaps this is not such a big deal.\n/**\n * Schedule afterPaintEffects flush after the browser paints\n * @param {number} newQueueLength\n * @returns {void}\n */\nfunction afterPaint(newQueueLength) {\n\tif (newQueueLength === 1 || prevRaf !== options.requestAnimationFrame) {\n\t\tprevRaf = options.requestAnimationFrame;\n\t\t(prevRaf || afterNextFrame)(flushAfterPaintEffects);\n\t}\n}\n\n/**\n * @param {import('./internal').HookState} hook\n * @returns {void}\n */\nfunction invokeCleanup(hook) {\n\t// A hook cleanup can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\tlet cleanup = hook._cleanup;\n\tif (typeof cleanup == 'function') {\n\t\thook._cleanup = undefined;\n\t\tcleanup();\n\t}\n\n\tcurrentComponent = comp;\n}\n\n/**\n * Invoke a Hook's effect\n * @param {import('./internal').EffectHookState} hook\n * @returns {void}\n */\nfunction invokeEffect(hook) {\n\t// A hook call can introduce a call to render which creates a new root, this will call options.vnode\n\t// and move the currentComponent away.\n\tconst comp = currentComponent;\n\thook._cleanup = hook._value();\n\tcurrentComponent = comp;\n}\n\n/**\n * @param {unknown[]} oldArgs\n * @param {unknown[]} newArgs\n * @returns {boolean}\n */\nfunction argsChanged(oldArgs, newArgs) {\n\treturn (\n\t\t!oldArgs ||\n\t\toldArgs.length !== newArgs.length ||\n\t\tnewArgs.some((arg, index) => arg !== oldArgs[index])\n\t);\n}\n\n/**\n * @template Arg\n * @param {Arg} arg\n * @param {(arg: Arg) => any} f\n * @returns {any}\n */\nfunction invokeOrReturn(arg, f) {\n\treturn typeof f == 'function' ? f(arg) : f;\n}\n", "import { h, createContext, cloneElement, toChildArray } from 'preact';\nimport { useContext, useMemo, useReducer, useLayoutEffect, useRef } from 'preact/hooks';\n\n/**\n * @template T\n * @typedef {import('preact').RefObject<T>} RefObject\n * @typedef {import('./internal.d.ts').VNode} VNode\n */\n\nlet push, scope;\nconst UPDATE = (state, url) => {\n\tpush = undefined;\n\tif (url && url.type === 'click') {\n\t\t// ignore events the browser takes care of already:\n\t\tif (url.ctrlKey || url.metaKey || url.altKey || url.shiftKey || url.button !== 0) {\n\t\t\treturn state;\n\t\t}\n\n\t\tconst link = url.composedPath().find(el => el.nodeName == 'A' && el.href),\n\t\t\thref = link && link.getAttribute('href');\n\t\tif (\n\t\t\t!link ||\n\t\t\tlink.origin != location.origin ||\n\t\t\t/^#/.test(href) ||\n\t\t\t!/^(_?self)?$/i.test(link.target) ||\n\t\t\tscope && (typeof scope == 'string'\n\t\t\t\t? !href.startsWith(scope)\n\t\t\t\t: !scope.test(href)\n\t\t\t)\n\t\t) {\n\t\t\treturn state;\n\t\t}\n\n\t\tpush = true;\n\t\turl.preventDefault();\n\t\turl = link.href.replace(location.origin, '');\n\t} else if (typeof url === 'string') {\n\t\tpush = true;\n\t} else if (url && url.url) {\n\t\tpush = !url.replace;\n\t\turl = url.url;\n\t} else {\n\t\turl = location.pathname + location.search;\n\t}\n\n\tif (push === true) history.pushState(null, '', url);\n\telse if (push === false) history.replaceState(null, '', url);\n\treturn url;\n};\n\nexport const exec = (url, route, matches = {}) => {\n\turl = url.split('/').filter(Boolean);\n\troute = (route || '').split('/').filter(Boolean);\n\tif (!matches.params) matches.params = {};\n\tfor (let i = 0, val, rest; i < Math.max(url.length, route.length); i++) {\n\t\tlet [, m, param, flag] = (route[i] || '').match(/^(:?)(.*?)([+*?]?)$/);\n\t\tval = url[i];\n\t\t// segment match:\n\t\tif (!m && param == val) continue;\n\t\t// /foo/* match\n\t\tif (!m && val && flag == '*') {\n\t\t\tmatches.rest = '/' + url.slice(i).map(decodeURIComponent).join('/');\n\t\t\tbreak;\n\t\t}\n\t\t// segment mismatch / missing required field:\n\t\tif (!m || (!val && flag != '?' && flag != '*')) return;\n\t\trest = flag == '+' || flag == '*';\n\t\t// rest (+/*) match:\n\t\tif (rest) val = url.slice(i).map(decodeURIComponent).join('/') || undefined;\n\t\t// normal/optional field:\n\t\telse if (val) val = decodeURIComponent(val);\n\t\tmatches.params[param] = val;\n\t\tif (!(param in matches)) matches[param] = val;\n\t\tif (rest) break;\n\t}\n\treturn matches;\n};\n\n/**\n * @type {import('./router.d.ts').LocationProvider}\n */\nexport function LocationProvider(props) {\n\t// @ts-expect-error - props.url is not implemented correctly & will be removed in the future\n\tconst [url, route] = useReducer(UPDATE, props.url || location.pathname + location.search);\n\tif (props.scope) scope = props.scope;\n\tconst wasPush = push === true;\n\n\tconst value = useMemo(() => {\n\t\tconst u = new URL(url, location.origin);\n\t\tconst path = u.pathname.replace(/\\/+$/g, '') || '/';\n\t\t// @ts-ignore-next\n\t\treturn {\n\t\t\turl,\n\t\t\tpath,\n\t\t\tquery: Object.fromEntries(u.searchParams),\n\t\t\troute: (url, replace) => route({ url, replace }),\n\t\t\twasPush\n\t\t};\n\t}, [url]);\n\n\tuseLayoutEffect(() => {\n\t\taddEventListener('click', route);\n\t\taddEventListener('popstate', route);\n\n\t\treturn () => {\n\t\t\tremoveEventListener('click', route);\n\t\t\tremoveEventListener('popstate', route);\n\t\t};\n\t}, []);\n\n\t// @ts-ignore\n\treturn h(LocationProvider.ctx.Provider, { value }, props.children);\n}\n\nconst RESOLVED = Promise.resolve();\n/** @this {import('./internal.d.ts').AugmentedComponent} */\nexport function Router(props) {\n\tconst [c, update] = useReducer(c => c + 1, 0);\n\n\tconst { url, query, wasPush, path } = useLocation();\n\tif (!url) {\n\t\tthrow new Error(`preact-iso's <Router> must be used within a <LocationProvider>, see: https://github.com/preactjs/preact-iso#locationprovider`);\n\t}\n\tconst { rest = path, params = {} } = useContext(RouteContext);\n\n\tconst isLoading = useRef(false);\n\tconst prevRoute = useRef(path);\n\t// Monotonic counter used to check if an un-suspending route is still the current route:\n\tconst count = useRef(0);\n\t// The current route:\n\tconst cur = /** @type {RefObject<VNode<any>>} */ (useRef());\n\t// Previous route (if current route is suspended):\n\tconst prev = /** @type {RefObject<VNode<any>>} */ (useRef());\n\t// A not-yet-hydrated DOM root to remove once we commit:\n\tconst pendingBase = /** @type {RefObject<Element | Text>} */ (useRef());\n\t// has this component ever successfully rendered without suspending:\n\tconst hasEverCommitted = useRef(false);\n\t// was the most recent render successful (did not suspend):\n\tconst didSuspend = /** @type {RefObject<boolean>} */ (useRef());\n\tdidSuspend.current = false;\n\n\tlet pathRoute, defaultRoute, matchProps;\n\ttoChildArray(props.children).some((/** @type {VNode<any>} */ vnode) => {\n\t\tconst matches = exec(rest, vnode.props.path, (matchProps = { ...vnode.props, path: rest, query, params, rest: '' }));\n\t\tif (matches) return (pathRoute = cloneElement(vnode, matchProps));\n\t\tif (vnode.props.default) defaultRoute = cloneElement(vnode, matchProps);\n\t});\n\n\t/** @type {VNode<any> | undefined} */\n\tlet incoming = pathRoute || defaultRoute;\n\n\tconst isHydratingSuspense = cur.current && cur.current.__u & MODE_HYDRATE && cur.current.__u & MODE_SUSPENDED;\n\tconst isHydratingBool = cur.current && cur.current.__h;\n\tconst routeChanged = useMemo(() => {\n\t\tprev.current = cur.current;\n\n\t\tcur.current = /** @type {VNode<any>} */ (h(RouteContext.Provider, { value: matchProps }, incoming));\n\n\t\t// Only mark as an update if the route component changed.\n\t\tconst outgoing = prev.current && prev.current.props.children;\n\t\tif (!outgoing || !incoming || incoming.type !== outgoing.type || incoming.props.component !== outgoing.props.component) {\n\t\t\t// This hack prevents Preact from diffing when we swap `cur` to `prev`:\n\t\t\tif (this.__v && this.__v.__k) this.__v.__k.reverse();\n\t\t\tcount.current++;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}, [url, JSON.stringify(matchProps)]);\n\n\tif (isHydratingSuspense) {\n\t\tcur.current.__u |= MODE_HYDRATE;\n\t\tcur.current.__u |= MODE_SUSPENDED;\n\t} else if (isHydratingBool) {\n\t\tcur.current.__h = true;\n\t}\n\n\t// Reset previous children - if rendering succeeds synchronously, we shouldn't render the previous children.\n\tconst p = prev.current;\n\tprev.current = null;\n\n\t// This borrows the _childDidSuspend() solution from compat.\n\tthis.__c = (e, suspendedVNode) => {\n\t\t// Mark the current render as having suspended:\n\t\tdidSuspend.current = true;\n\n\t\t// The new route suspended, so keep the previous route around while it loads:\n\t\tprev.current = p;\n\n\t\t// Fire an event saying we're waiting for the route:\n\t\tif (props.onLoadStart) props.onLoadStart(url);\n\t\tisLoading.current = true;\n\n\t\t// Re-render on unsuspend:\n\t\tlet c = count.current;\n\t\te.then(() => {\n\t\t\t// Ignore this update if it isn't the most recently suspended update:\n\t\t\tif (c !== count.current) return;\n\n\t\t\t// Successful route transition: un-suspend after a tick and stop rendering the old route:\n\t\t\tprev.current = null;\n\t\t\tif (cur.current) {\n\t\t\t\tif (suspendedVNode.__h) {\n\t\t\t\t\t// _hydrating\n\t\t\t\t\tcur.current.__h = suspendedVNode.__h;\n\t\t\t\t}\n\n\t\t\t\tif (suspendedVNode.__u & MODE_SUSPENDED) {\n\t\t\t\t\t// _flags\n\t\t\t\t\tcur.current.__u |= MODE_SUSPENDED;\n\t\t\t\t}\n\n\t\t\t\tif (suspendedVNode.__u & MODE_HYDRATE) {\n\t\t\t\t\tcur.current.__u |= MODE_HYDRATE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRESOLVED.then(update);\n\t\t});\n\t};\n\n\tuseLayoutEffect(() => {\n\t\tconst currentDom = this.__v && this.__v.__e;\n\n\t\t// Ignore suspended renders (failed commits):\n\t\tif (didSuspend.current) {\n\t\t\t// If we've never committed, mark any hydration DOM for removal on the next commit:\n\t\t\tif (!hasEverCommitted.current && !pendingBase.current) {\n\t\t\t\tpendingBase.current = currentDom;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// If this is the first ever successful commit and we didn't use the hydration DOM, remove it:\n\t\tif (!hasEverCommitted.current && pendingBase.current) {\n\t\t\tif (pendingBase.current !== currentDom) pendingBase.current.remove();\n\t\t\tpendingBase.current = null;\n\t\t}\n\n\t\t// Mark the component has having committed:\n\t\thasEverCommitted.current = true;\n\n\t\t// The route is loaded and rendered.\n\t\tif (prevRoute.current !== path) {\n\t\t\tif (wasPush) scrollTo(0, 0);\n\t\t\tif (props.onRouteChange) props.onRouteChange(url);\n\n\t\t\tprevRoute.current = path;\n\t\t}\n\n\t\tif (props.onLoadEnd && isLoading.current) props.onLoadEnd(url);\n\t\tisLoading.current = false;\n\t}, [path, wasPush, c]);\n\n\t// Note: cur MUST render first in order to set didSuspend & prev.\n\treturn routeChanged\n\t\t? [h(RenderRef, { r: cur }), h(RenderRef, { r: prev })]\n\t\t: h(RenderRef, { r: cur });\n}\n\nconst MODE_HYDRATE = 1 << 5;\nconst MODE_SUSPENDED = 1 << 7;\n\n// Lazily render a ref's current value:\nconst RenderRef = ({ r }) => r.current;\n\nRouter.Provider = LocationProvider;\n\nLocationProvider.ctx = createContext(\n\t/** @type {import('./router.d.ts').LocationHook & { wasPush: boolean }} */ ({})\n);\nconst RouteContext = createContext(\n\t/** @type {import('./router.d.ts').RouteHook & { rest: string }} */ ({})\n);\n\nexport const Route = props => h(props.component, props);\n\nexport const useLocation = () => useContext(LocationProvider.ctx);\nexport const useRoute = () => useContext(RouteContext);\n", "import { h, options } from 'preact';\nimport { useState, useRef } from 'preact/hooks';\n\nconst oldDiff = options.__b;\noptions.__b = (vnode) => {\n\tif (vnode.type && vnode.type._forwarded && vnode.ref) {\n\t\tvnode.props.ref = vnode.ref;\n\t\tvnode.ref = null;\n\t}\n\tif (oldDiff) oldDiff(vnode);\n};\n\nexport default function lazy(load) {\n\tlet p, c;\n\n\tconst loadModule = () =>\n\t\tload().then(m => (c = (m && m.default) || m));\n\n\tconst LazyComponent = props => {\n\t\tconst [, update] = useState(0);\n\t\tconst r = useRef(c);\n\t\tif (!p) p = loadModule();\n\t\tif (c !== undefined) return h(c, props);\n\t\tif (!r.current) r.current = p.then(() => update(1));\n\t\tthrow p;\n\t};\n\n\tLazyComponent.preload = () => {\n\t\tif (!p) p = loadModule();\n\t\treturn p;\n\t}\n\n\tLazyComponent._forwarded = true;\n\treturn LazyComponent;\n}\n\n// See https://github.com/preactjs/preact/blob/88680e91ec0d5fc29d38554a3e122b10824636b6/compat/src/suspense.js#L5\nconst oldCatchError = options.__e;\noptions.__e = (err, newVNode, oldVNode) => {\n\tif (err && err.then) {\n\t\tlet v = newVNode;\n\t\twhile ((v = v.__)) {\n\t\t\tif (v.__c && v.__c.__c) {\n\t\t\t\tif (newVNode.__e == null) {\n\t\t\t\t\tnewVNode.__c.__z = [oldVNode.__e];\n\t\t\t\t\tnewVNode.__e = oldVNode.__e; // ._dom\n\t\t\t\t\tnewVNode.__k = oldVNode.__k; // ._children\n\t\t\t\t}\n\t\t\t\tif (!newVNode.__k) newVNode.__k = [];\n\t\t\t\treturn v.__c.__c(err, newVNode);\n\t\t\t}\n\t\t}\n\t}\n\tif (oldCatchError) oldCatchError(err, newVNode, oldVNode);\n};\n\nexport function ErrorBoundary(props) {\n\tthis.__c = childDidSuspend;\n\tthis.componentDidCatch = props.onError;\n\treturn props.children;\n}\n\nfunction childDidSuspend(err) {\n\terr.then(() => this.forceUpdate());\n}\n", "import { render, hydrate as hydrativeRender } from 'preact';\n\nlet initialized;\n\n/** @type {typeof hydrativeRender} */\nexport default function hydrate(jsx, parent) {\n\tif (typeof window === 'undefined') return;\n\tlet isodata = document.querySelector('script[type=isodata]');\n\t// @ts-ignore-next\n\tparent = parent || (isodata && isodata.parentNode) || document.body;\n\tif (!initialized && isodata) {\n\t\thydrativeRender(jsx, parent);\n\t} else {\n\t\trender(jsx, parent);\n\t}\n\tinitialized = true;\n}\n", "export { Router, LocationProvider, useLocation, Route, useRoute } from './router.js';\nexport { default as lazy, ErrorBoundary } from './lazy.js';\nexport { default as hydrate } from './hydrate.js';\n\nexport function prerender(vnode, options) {\n\treturn import('./prerender.js').then(m => m.default(vnode, options));\n}\n"],
  "mappings": "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",
  "names": ["currentIndex", "currentComponent", "previousComponent", "prevRaf", "currentHook", "afterPaintEffects", "options", "_options", "oldBeforeDiff", "__b", "oldBeforeRender", "__r", "oldAfterDiff", "diffed", "oldCommit", "__c", "oldBeforeUnmount", "unmount", "oldRoot", "__", "getHookState", "index", "type", "__h", "hooks", "__H", "length", "push", "useState", "initialState", "useReducer", "invokeOrReturn", "reducer", "init", "hookState", "_reducer", "action", "currentValue", "__N", "nextValue", "setState", "__f", "updateHookState", "p", "s", "c", "stateHooks", "filter", "x", "every", "prevScu", "call", "this", "shouldUpdate", "props", "forEach", "hookItem", "shouldComponentUpdate", "prevCWU", "componentWillUpdate", "__e", "tmp", "useLayoutEffect", "callback", "args", "state", "getHookState", "currentIndex", "options", "__s", "argsChanged", "__H", "__", "_pendingArgs", "currentComponent", "__h", "push", "useRef", "initialValue", "currentHook", "useMemo", "current", "useMemo", "factory", "args", "state", "getHookState", "currentIndex", "argsChanged", "__H", "__", "__h", "useContext", "context", "provider", "currentComponent", "__c", "state", "getHookState", "currentIndex", "c", "__", "sub", "props", "value", "flushAfterPaintEffects", "component", "afterPaintEffects", "shift", "__P", "__H", "__h", "forEach", "invokeCleanup", "invokeEffect", "e", "options", "__e", "__v", "__b", "vnode", "currentComponent", "oldBeforeDiff", "__", "parentDom", "__k", "__m", "oldRoot", "__r", "oldBeforeRender", "currentIndex", "hooks", "__c", "previousComponent", "hookItem", "__N", "_pendingArgs", "diffed", "oldAfterDiff", "c", "length", "push", "prevRaf", "requestAnimationFrame", "afterNextFrame", "commitQueue", "some", "filter", "cb", "oldCommit", "unmount", "oldBeforeUnmount", "hasErrored", "s", "HAS_RAF", "callback", "raf", "done", "clearTimeout", "timeout", "cancelAnimationFrame", "setTimeout", "hook", "comp", "cleanup", "argsChanged", "oldArgs", "newArgs", "arg", "index", "invokeOrReturn", "f", "i", "m", "u", "url", "_", "c", "p", "e", "r", "p", "c", "m", "r", "v", "m"]
}
