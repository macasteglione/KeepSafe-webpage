import {
  E,
  G,
  H,
  J,
  K,
  _,
  l
} from "./chunk-ZU3A5VCS.js";

// node_modules/preact/hooks/dist/hooks.module.js
var t;
var r;
var u;
var i;
var o = 0;
var f = [];
var c = l;
var e = c.__b;
var a = c.__r;
var v = c.diffed;
var l2 = c.__c;
var m = c.unmount;
var s = c.__;
function p(n, t2) {
  c.__h && c.__h(r, n, o || t2), o = 0;
  var u2 = r.__H || (r.__H = { __: [], __h: [] });
  return n >= u2.__.length && u2.__.push({}), u2.__[n];
}
function d(n) {
  return o = 1, h(D, n);
}
function h(n, u2, i2) {
  var o2 = p(t++, 2);
  if (o2.t = n, !o2.__c && (o2.__ = [i2 ? i2(u2) : D(void 0, u2), function(n2) {
    var t2 = o2.__N ? o2.__N[0] : o2.__[0], r2 = o2.t(t2, n2);
    t2 !== r2 && (o2.__N = [r2, o2.__[1]], o2.__c.setState({}));
  }], o2.__c = r, !r.__f)) {
    var f2 = function(n2, t2, r2) {
      if (!o2.__c.__H) return true;
      var u3 = o2.__c.__H.__.filter(function(n3) {
        return !!n3.__c;
      });
      if (u3.every(function(n3) {
        return !n3.__N;
      })) return !c2 || c2.call(this, n2, t2, r2);
      var i3 = o2.__c.props !== n2;
      return u3.forEach(function(n3) {
        if (n3.__N) {
          var t3 = n3.__[0];
          n3.__ = n3.__N, n3.__N = void 0, t3 !== n3.__[0] && (i3 = true);
        }
      }), c2 && c2.call(this, n2, t2, r2) || i3;
    };
    r.__f = true;
    var c2 = r.shouldComponentUpdate, e2 = r.componentWillUpdate;
    r.componentWillUpdate = function(n2, t2, r2) {
      if (this.__e) {
        var u3 = c2;
        c2 = void 0, f2(n2, t2, r2), c2 = u3;
      }
      e2 && e2.call(this, n2, t2, r2);
    }, r.shouldComponentUpdate = f2;
  }
  return o2.__N || o2.__;
}
function _2(n, u2) {
  var i2 = p(t++, 4);
  !c.__s && C(i2.__H, u2) && (i2.__ = n, i2.u = u2, r.__h.push(i2));
}
function A(n) {
  return o = 5, T(function() {
    return { current: n };
  }, []);
}
function T(n, r2) {
  var u2 = p(t++, 7);
  return C(u2.__H, r2) && (u2.__ = n(), u2.__H = r2, u2.__h = n), u2.__;
}
function x(n) {
  var u2 = r.context[n.__c], i2 = p(t++, 9);
  return i2.c = n, u2 ? (null == i2.__ && (i2.__ = true, u2.sub(r)), u2.props.value) : n.__;
}
function j() {
  for (var n; n = f.shift(); ) if (n.__P && n.__H) try {
    n.__H.__h.forEach(z), n.__H.__h.forEach(B), n.__H.__h = [];
  } catch (t2) {
    n.__H.__h = [], c.__e(t2, n.__v);
  }
}
c.__b = function(n) {
  r = null, e && e(n);
}, c.__ = function(n, t2) {
  n && t2.__k && t2.__k.__m && (n.__m = t2.__k.__m), s && s(n, t2);
}, c.__r = function(n) {
  a && a(n), t = 0;
  var i2 = (r = n.__c).__H;
  i2 && (u === r ? (i2.__h = [], r.__h = [], i2.__.forEach(function(n2) {
    n2.__N && (n2.__ = n2.__N), n2.u = n2.__N = void 0;
  })) : (i2.__h.forEach(z), i2.__h.forEach(B), i2.__h = [], t = 0)), u = r;
}, c.diffed = function(n) {
  v && v(n);
  var t2 = n.__c;
  t2 && t2.__H && (t2.__H.__h.length && (1 !== f.push(t2) && i === c.requestAnimationFrame || ((i = c.requestAnimationFrame) || w)(j)), t2.__H.__.forEach(function(n2) {
    n2.u && (n2.__H = n2.u), n2.u = void 0;
  })), u = r = null;
}, c.__c = function(n, t2) {
  t2.some(function(n2) {
    try {
      n2.__h.forEach(z), n2.__h = n2.__h.filter(function(n3) {
        return !n3.__ || B(n3);
      });
    } catch (r2) {
      t2.some(function(n3) {
        n3.__h && (n3.__h = []);
      }), t2 = [], c.__e(r2, n2.__v);
    }
  }), l2 && l2(n, t2);
}, c.unmount = function(n) {
  m && m(n);
  var t2, r2 = n.__c;
  r2 && r2.__H && (r2.__H.__.forEach(function(n2) {
    try {
      z(n2);
    } catch (n3) {
      t2 = n3;
    }
  }), r2.__H = void 0, t2 && c.__e(t2, r2.__v));
};
var k = "function" == typeof requestAnimationFrame;
function w(n) {
  var t2, r2 = function() {
    clearTimeout(u2), k && cancelAnimationFrame(t2), setTimeout(n);
  }, u2 = setTimeout(r2, 35);
  k && (t2 = requestAnimationFrame(r2));
}
function z(n) {
  var t2 = r, u2 = n.__c;
  "function" == typeof u2 && (n.__c = void 0, u2()), r = t2;
}
function B(n) {
  var t2 = r;
  n.__c = n.__(), r = t2;
}
function C(n, t2) {
  return !n || n.length !== t2.length || t2.some(function(t3, r2) {
    return t3 !== n[r2];
  });
}
function D(n, t2) {
  return "function" == typeof t2 ? t2(n) : t2;
}

// node_modules/preact-iso/src/router.js
var push;
var scope;
var UPDATE = (state, url) => {
  push = void 0;
  if (url && url.type === "click") {
    if (url.ctrlKey || url.metaKey || url.altKey || url.shiftKey || url.button !== 0) {
      return state;
    }
    const link = url.composedPath().find((el) => el.nodeName == "A" && el.href), href = link && link.getAttribute("href");
    if (!link || link.origin != location.origin || /^#/.test(href) || !/^(_?self)?$/i.test(link.target) || scope && (typeof scope == "string" ? !href.startsWith(scope) : !scope.test(href))) {
      return state;
    }
    push = true;
    url.preventDefault();
    url = link.href.replace(location.origin, "");
  } else if (typeof url === "string") {
    push = true;
  } else if (url && url.url) {
    push = !url.replace;
    url = url.url;
  } else {
    url = location.pathname + location.search;
  }
  if (push === true) history.pushState(null, "", url);
  else if (push === false) history.replaceState(null, "", url);
  return url;
};
var exec = (url, route, matches = {}) => {
  url = url.split("/").filter(Boolean);
  route = (route || "").split("/").filter(Boolean);
  if (!matches.params) matches.params = {};
  for (let i2 = 0, val, rest; i2 < Math.max(url.length, route.length); i2++) {
    let [, m2, param, flag] = (route[i2] || "").match(/^(:?)(.*?)([+*?]?)$/);
    val = url[i2];
    if (!m2 && param == val) continue;
    if (!m2 && val && flag == "*") {
      matches.rest = "/" + url.slice(i2).map(decodeURIComponent).join("/");
      break;
    }
    if (!m2 || !val && flag != "?" && flag != "*") return;
    rest = flag == "+" || flag == "*";
    if (rest) val = url.slice(i2).map(decodeURIComponent).join("/") || void 0;
    else if (val) val = decodeURIComponent(val);
    matches.params[param] = val;
    if (!(param in matches)) matches[param] = val;
    if (rest) break;
  }
  return matches;
};
function LocationProvider(props) {
  const [url, route] = h(UPDATE, props.url || location.pathname + location.search);
  if (props.scope) scope = props.scope;
  const wasPush = push === true;
  const value = T(() => {
    const u2 = new URL(url, location.origin);
    const path = u2.pathname.replace(/\/+$/g, "") || "/";
    return {
      url,
      path,
      query: Object.fromEntries(u2.searchParams),
      route: (url2, replace) => route({ url: url2, replace }),
      wasPush
    };
  }, [url]);
  _2(() => {
    addEventListener("click", route);
    addEventListener("popstate", route);
    return () => {
      removeEventListener("click", route);
      removeEventListener("popstate", route);
    };
  }, []);
  return _(LocationProvider.ctx.Provider, { value }, props.children);
}
var RESOLVED = Promise.resolve();
function Router(props) {
  const [c2, update] = h((c3) => c3 + 1, 0);
  const { url, query, wasPush, path } = useLocation();
  if (!url) {
    throw new Error(`preact-iso's <Router> must be used within a <LocationProvider>, see: https://github.com/preactjs/preact-iso#locationprovider`);
  }
  const { rest = path, params = {} } = x(RouteContext);
  const isLoading = A(false);
  const prevRoute = A(path);
  const count = A(0);
  const cur = (
    /** @type {RefObject<VNode<any>>} */
    A()
  );
  const prev = (
    /** @type {RefObject<VNode<any>>} */
    A()
  );
  const pendingBase = (
    /** @type {RefObject<Element | Text>} */
    A()
  );
  const hasEverCommitted = A(false);
  const didSuspend = (
    /** @type {RefObject<boolean>} */
    A()
  );
  didSuspend.current = false;
  let pathRoute, defaultRoute, matchProps;
  H(props.children).some((vnode) => {
    const matches = exec(rest, vnode.props.path, matchProps = { ...vnode.props, path: rest, query, params, rest: "" });
    if (matches) return pathRoute = J(vnode, matchProps);
    if (vnode.props.default) defaultRoute = J(vnode, matchProps);
  });
  let incoming = pathRoute || defaultRoute;
  const isHydratingSuspense = cur.current && cur.current.__u & MODE_HYDRATE && cur.current.__u & MODE_SUSPENDED;
  const isHydratingBool = cur.current && cur.current.__h;
  const routeChanged = T(() => {
    prev.current = cur.current;
    cur.current = /** @type {VNode<any>} */
    _(RouteContext.Provider, { value: matchProps }, incoming);
    const outgoing = prev.current && prev.current.props.children;
    if (!outgoing || !incoming || incoming.type !== outgoing.type || incoming.props.component !== outgoing.props.component) {
      if (this.__v && this.__v.__k) this.__v.__k.reverse();
      count.current++;
      return true;
    }
    return false;
  }, [url, JSON.stringify(matchProps)]);
  if (isHydratingSuspense) {
    cur.current.__u |= MODE_HYDRATE;
    cur.current.__u |= MODE_SUSPENDED;
  } else if (isHydratingBool) {
    cur.current.__h = true;
  }
  const p2 = prev.current;
  prev.current = null;
  this.__c = (e2, suspendedVNode) => {
    didSuspend.current = true;
    prev.current = p2;
    if (props.onLoadStart) props.onLoadStart(url);
    isLoading.current = true;
    let c3 = count.current;
    e2.then(() => {
      if (c3 !== count.current) return;
      prev.current = null;
      if (cur.current) {
        if (suspendedVNode.__h) {
          cur.current.__h = suspendedVNode.__h;
        }
        if (suspendedVNode.__u & MODE_SUSPENDED) {
          cur.current.__u |= MODE_SUSPENDED;
        }
        if (suspendedVNode.__u & MODE_HYDRATE) {
          cur.current.__u |= MODE_HYDRATE;
        }
      }
      RESOLVED.then(update);
    });
  };
  _2(() => {
    const currentDom = this.__v && this.__v.__e;
    if (didSuspend.current) {
      if (!hasEverCommitted.current && !pendingBase.current) {
        pendingBase.current = currentDom;
      }
      return;
    }
    if (!hasEverCommitted.current && pendingBase.current) {
      if (pendingBase.current !== currentDom) pendingBase.current.remove();
      pendingBase.current = null;
    }
    hasEverCommitted.current = true;
    if (prevRoute.current !== path) {
      if (wasPush) scrollTo(0, 0);
      if (props.onRouteChange) props.onRouteChange(url);
      prevRoute.current = path;
    }
    if (props.onLoadEnd && isLoading.current) props.onLoadEnd(url);
    isLoading.current = false;
  }, [path, wasPush, c2]);
  return routeChanged ? [_(RenderRef, { r: cur }), _(RenderRef, { r: prev })] : _(RenderRef, { r: cur });
}
var MODE_HYDRATE = 1 << 5;
var MODE_SUSPENDED = 1 << 7;
var RenderRef = ({ r: r2 }) => r2.current;
Router.Provider = LocationProvider;
LocationProvider.ctx = K(
  /** @type {import('./router.d.ts').LocationHook & { wasPush: boolean }} */
  {}
);
var RouteContext = K(
  /** @type {import('./router.d.ts').RouteHook & { rest: string }} */
  {}
);
var Route = (props) => _(props.component, props);
var useLocation = () => x(LocationProvider.ctx);
var useRoute = () => x(RouteContext);

// node_modules/preact-iso/src/lazy.js
var oldDiff = l.__b;
l.__b = (vnode) => {
  if (vnode.type && vnode.type._forwarded && vnode.ref) {
    vnode.props.ref = vnode.ref;
    vnode.ref = null;
  }
  if (oldDiff) oldDiff(vnode);
};
function lazy(load) {
  let p2, c2;
  const loadModule = () => load().then((m2) => c2 = m2 && m2.default || m2);
  const LazyComponent = (props) => {
    const [, update] = d(0);
    const r2 = A(c2);
    if (!p2) p2 = loadModule();
    if (c2 !== void 0) return _(c2, props);
    if (!r2.current) r2.current = p2.then(() => update(1));
    throw p2;
  };
  LazyComponent.preload = () => {
    if (!p2) p2 = loadModule();
    return p2;
  };
  LazyComponent._forwarded = true;
  return LazyComponent;
}
var oldCatchError = l.__e;
l.__e = (err, newVNode, oldVNode) => {
  if (err && err.then) {
    let v2 = newVNode;
    while (v2 = v2.__) {
      if (v2.__c && v2.__c.__c) {
        if (newVNode.__e == null) {
          newVNode.__c.__z = [oldVNode.__e];
          newVNode.__e = oldVNode.__e;
          newVNode.__k = oldVNode.__k;
        }
        if (!newVNode.__k) newVNode.__k = [];
        return v2.__c.__c(err, newVNode);
      }
    }
  }
  if (oldCatchError) oldCatchError(err, newVNode, oldVNode);
};
function ErrorBoundary(props) {
  this.__c = childDidSuspend;
  this.componentDidCatch = props.onError;
  return props.children;
}
function childDidSuspend(err) {
  err.then(() => this.forceUpdate());
}

// node_modules/preact-iso/src/hydrate.js
var initialized;
function hydrate(jsx, parent) {
  if (typeof window === "undefined") return;
  let isodata = document.querySelector("script[type=isodata]");
  parent = parent || isodata && isodata.parentNode || document.body;
  if (!initialized && isodata) {
    G(jsx, parent);
  } else {
    E(jsx, parent);
  }
  initialized = true;
}

// node_modules/preact-iso/src/index.js
function prerender(vnode, options) {
  return import("./prerender-HJFR65YD.js").then((m2) => m2.default(vnode, options));
}
export {
  ErrorBoundary,
  LocationProvider,
  Route,
  Router,
  hydrate,
  lazy,
  prerender,
  useLocation,
  useRoute
};
//# sourceMappingURL=preact-iso.js.map
